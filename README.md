# Java Performance Analyzer
우테코 8기 프리코스 오픈 미션

# 1. 프로젝트 개요

> 프리코스 기간 동안 사용한 String 덧셈, ArrayList 등이 실제로 JVM 위에서 성능이 얼마나 차이나는지 궁금하여 CLI 기반의 성능 비교 도구를 만들게 되었습니다.

1. 자바 기능들의 성능 차이를 데이터로 확인한다.
2. CLI 기반으로 결과를 보여준다.
3. 코드가 느린 이유를 분석한다.

# 2. 기능 목록

## 2.1. 사용자 인터페이스
- [x]  메인 메뉴(분석 항목 1~10, 종료 0)를 출력한다.
- [x]  사용자로부터 메뉴 번호를 입력받는다.
    - [x]  사용자 입력이 '0'일 경우, 프로그램을 종료한다.
    - [x]  해당하는 번호의 분석 모듈을 호출한다.
    - [x]  분석 모듈의 실행 결과를 출력한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
    - [x]  각 분석 항목별로 권장 반복 횟수 가이드를 출력한다.
    - [x]  사용자로부터 반복 횟수를 입력받아, 데이터 크기에 따른 성능 변화를 체감할 수 있게 한다.
- [x]  유효하지 않은 입력을 받을 시, 에러 메시지를 출력하고 메뉴를 재출력한다.
    - [x]  입력값이 없는 경우
    - [x]  숫자 외의 문자를 입력하는 경우
    - [x]  메뉴에 없는 숫자를 입력하는 경우
- [x]  입력 스트림이 종료되는 경우 프로그램을 종료한다.

## 2.2. 성능 비교 항목

### 2.2.1. String 연결 성능 비교
String의 불변성과 StringBuilder의 가변성의 성능 차이를 확인한다.
- **String 덧셈:** 빈 문자열에 작은 문자열을 100만 번 덧셈한다.
  - [x]  분석 모듈 실행 전의 시간을 기록한다.
  - [x]  빈 문자열에 작은 문자열을 더하는 연산을 수행한다.
  - [x]  분석 모듈 실행 후의 시간을 기록한다.
  - [x]  총 소요 시간을 계산한다.
- **StringBuilder:** `StringBuilder` 객체에 작은 문자열을 100만 번 추가한다.
  - [x]  분석 모듈 실행 전의 시간을 기록한다.
  - [x]  `StringBuilder`에 작은 문자열을 추가하는 연산을 수행한다.
  - [x]  분석 모듈 실행 후의 시간을 기록한다.
  - [x]  총 소요 시간을 계산한다.

### 2.2.2. List 중간 삽입 성능 비교
배열 기반 List와 연결 기반 List의 구조적 차이로 인한 중간 삽입 성능 차이를 확인한다.
- **ArrayList 중간 삽입:** List의 중간 인덱스에 새로운 요소를 100만 번 삽입한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  ArrayList의 중간 인덱스에 새로운 요소를 100만 번 삽입한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **LinkedList 중간 삽입:** List의 중간 인덱스에 새로운 요소를 100만 번 삽입한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  LinkedList의 중간 인덱스에 새로운 요소를 100만 번 삽입한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.3. List 순차 등록 성능 비교
Node 객체 생성 오버헤드와 캐시 지역성을 통해 순차 삽입 성능 차이를 확인한다.
- **LinkedList 순차 삽입:** List의 끝에 새로운 요소를 100만 번 추가한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  LinkedList의 끝에 새로운 요소를 100만 번 추가한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **ArrayList 순차 삽입:** List의 끝에 새로운 요소를 100만 번 추가한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  ArrayList의 끝에 새로운 요소를 100만 번 추가한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.4. Stream 반복 성능 비교
Stream 파이프라인 처리 오버헤드와 단순 반복문의 성능 차이를 확인한다.
- **Stream.forEach:** `stream().forEach()`를 사용하여 List의 각 요소에 접근한다.
    - [x]  테스트를 위한 List 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  Stream을 사용하여 각 요소에 접근한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **Enhanced For Loop:** 향상된 `for` 문을 사용하여 List의 각 요소에 접근한다.
    - [x]  테스트를 위한 List 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `for-each` 구문을 사용하여 각 요소에 접근한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.5. 컬렉션 요소 포함 확인 성능 비교
자료구조의 탐색 시간 복잡도(O(N) vs O(1)) 차이로 인한 성능 차이를 확인한다.
- **ArrayList.contains:** `contains()` 메서드를 사용하여 리스트 내 요소를 순차적으로 탐색한다.
    - [x]  테스트를 위한 List 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `contains()`를 사용하여 요소를 탐색한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **HashSet.contains:** `contains()` 메서드를 사용하여 해싱(Hashing)을 통해 요소를 즉시 탐색한다.
    - [x]  테스트를 위한 Set 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `contains()`를 사용하여 요소를 탐색한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.6. 배열 대량 복사 성능 비교
배열을 복사할 때, 반복문을 사용하는 방식과 JVM Native 기능을 사용하는 방식의 성능 차이를 확인한다.
- **For Loop Copy:** `for` 루프를 순회하며 인덱스 단위로 값을 하나씩 복사한다.
    - [x]  테스트를 위한 원본 배열과 복사 대상 배열을 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `for` 루프를 사용하여 배열 요소를 수동으로 복사한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **System.arraycopy:** JVM의 `System.arraycopy()`를 사용하여 메모리 블록을 통째로 복사한다.
    - [x]  테스트를 위한 원본 배열과 복사 대상 배열을 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `System.arraycopy()`를 사용하여 배열을 복사한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.7. 키 기반 Map 조회 성능 비교
데이터 저장 구조(Tree vs Hash Table)의 차이가 조회 성능에 미치는 영향을 확인한다.
- **TreeMap.get:** 이진 트리 구조를 타고 내려가며 키를 탐색한다.
    - [x]  테스트를 위한 TreeMap 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `get()` 메서드를 사용하여 키에 매핑된 값을 조회한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **HashMap.get:** 키의 해시(Hash) 값을 계산하여 데이터 위치에 즉시 접근한다.
    - [x]  테스트를 위한 HashMap 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `get()` 메서드를 사용하여 키에 매핑된 값을 조회한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.8. 단순 문자열 치환 성능 비교
단순한 문자열을 치환할 때, 정규 표현식 엔진 사용 여부에 따른 성능 차이를 확인한다.
- **String.replaceAll:** 내부적으로 정규 표현식(Regex) 엔진을 사용하여 문자열을 치환한다.
    - [x]  테스트를 위한 원본 문자열을 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `replaceAll()`을 사용하여 정규 표현식 기반으로 문자열을 치환한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **String.replace:** 단순 문자열 매칭 알고리즘을 사용하여 문자열을 치환한다.
    - [x]  테스트를 위한 원본 문자열을 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `replace()`를 사용하여 리터럴 문자열 기반으로 치환한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.9. List 반복 중 안전한 삭제 비교
List를 순회하며 요소를 삭제할 때, 인덱스를 직접 다루는 방식과 Iterator를 사용하는 방식의 성능 차이를 확인한다.
- **For Loop remove(i):** 인덱스 기반 루프 내에서 `ArrayList.remove(i)`를 호출하며, 인덱스 시프트를 직접 관리한다.
    - [x]  테스트를 위한 List 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `for` 루프를 돌며 요소를 삭제하고, 인덱스 위치를 수동으로 조정(`i--`)한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **Iterator.remove:** `Iterator`의 `remove()` 메서드를 사용하여 요소를 삭제하므로, 인덱스를 별도로 관리할 필요가 없다.
    - [x]  테스트를 위한 List 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `Iterator`의 `remove()` 메서드를 사용하여 요소를 삭제한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

### 2.2.10. 병렬 스트림 성능 비교
단순 반복 작업에서 작업량에 따른 직렬(Sequential)과 병렬(Parallel) 처리의 효율성을 비교한다.
- **Stream (Sequential):** 단일 스레드에서 순차적으로 스트림을 처리한다.
    - [x]  테스트를 위한 List 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `stream()`(직렬)을 사용하여 요소를 순회한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.
- **Parallel Stream:** 멀티 스레드를 사용하여 작업을 병렬로 처리한다.
    - [x]  테스트를 위한 List 데이터를 생성한다.
    - [x]  분석 모듈 실행 전의 시간을 기록한다.
    - [x]  `parallelStream()`(병렬)을 사용하여 요소를 순회한다.
    - [x]  분석 모듈 실행 후의 시간을 기록한다.
    - [x]  총 소요 시간을 계산한다.

## 2.3. 결과 출력 및 비교
- **측정 단위 변환:** 나노초(ns)로 측정된 시간을 가독성 좋게 변환한다.
    - [x]  1,000ms 미만은 밀리초(ms)로, 1,000ms 이상은 초(s)로 변환하여 출력한다.
- **출력 포맷팅:** 수치 데이터의 가독성을 높인다.
    - [x]  반복 횟수와 소요 시간 출력 시 천 단위 구분 기호(,)를 적용한다.
- **성능 차이 분석:** 두 방식의 성능 효율을 계산한다.
    - [x]  (느린 시간 / 빠른 시간) 공식을 사용하여 성능 차이 배수를 계산한다.
    - [x]  "A가 B보다 약 XX.XX배 빠릅니다" 형식으로 비교 결과를 출력한다.
- **성능 시각화:** 텍스트 기반 환경(CLI)에서도 성능 차이를 한눈에 볼 수 있도록 시각화한다.
    - [x]  가장 느린 결과(100%)를 기준으로 상대적인 속도 비율을 계산한다.
    - [x]  `█` 문자를 활용하여 막대 그래프(Bar Chart)를 출력한다.
- **비교 예외 처리:** 유효성 검사를 수행한다.
    - [x]  두 테스트의 반복 횟수가 다를 경우, 비교를 건너뛰고 안내 메시지를 출력한다.