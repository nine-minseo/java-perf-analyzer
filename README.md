# Java Performance Analyzer
우테코 8기 프리코스 오픈 미션

# 1. 프로젝트 개요

> 프리코스 기간 동안 사용한 String 덧셈, ArrayList 등이 실제로 JVM 위에서 성능이 얼마나 차이나는지 궁금하여 CLI 기반의 성능 비교 도구를 만들게 되었습니다.

1. 자바 기능들의 성능 차이를 데이터로 확인한다.
2. CLI 기반으로 결과를 보여준다.
3. 코드가 느린 이유를 분석한다.

# 2. 기능 목록

## 2.1. 사용자 인터페이스
- [x]  메인 메뉴(분석 항목 1~10, 종료 0)를 출력한다.
- [x]  사용자의 시스템 환경 정보를 출력한다.
    - [x]  OS, 아키텍처, Java 버전을 출력한다.
    - [x]  병렬 처리 성능과 연관된 CPU 코어(Logical Processors) 수를 출력한다.
- [x]  사용자로부터 메뉴 번호를 입력받는다.
    - [x]  사용자 입력이 '0'일 경우, 프로그램을 종료한다.
    - [x]  해당하는 번호의 분석 모듈을 호출한다.
    - [x]  분석 모듈의 실행 결과를 출력한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
    - [x]  각 분석 항목별로 권장 반복 횟수 가이드를 출력한다.
    - [x]  사용자로부터 반복 횟수를 입력받아, 데이터 크기에 따른 성능 변화를 체감할 수 있게 한다.
- [x]  유효하지 않은 입력을 받을 시, 에러 메시지를 출력하고 메뉴를 재출력한다.
    - [x]  입력값이 없는 경우
    - [x]  숫자 외의 문자를 입력하는 경우
    - [x]  메뉴에 없는 숫자를 입력하는 경우
- [x]  입력 스트림이 종료되는 경우 프로그램을 종료한다.

## 2.2. 성능 비교 항목
모든 분석은 사용자가 입력한 반복 횟수(N)를 기준으로 수행된다.

### 2.2.1. String 연결 성능 비교
String의 불변성과 StringBuilder의 가변성의 성능 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **String 덧셈:** 빈 문자열에 문자열을 N번 더하며 시간을 측정한다.
- [x]  **StringBuilder:** 객체에 문자열을 N번 append하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.2. List 중간 삽입 성능 비교
배열 기반 List와 연결 기반 List의 구조적 차이로 인한 중간 삽입 성능 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **ArrayList 중간 삽입:** 리스트의 중간 인덱스에 요소를 N번 삽입하며 시간을 측정한다.
- [x]  **LinkedList 중간 삽입:** 리스트의 중간 인덱스에 요소를 N번 삽입하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.3. List 순차 등록 성능 비교
Node 객체 생성 오버헤드와 캐시 지역성을 통해 순차 삽입 성능 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **LinkedList 순차 삽입:** 리스트의 끝에 요소를 N번 추가하며 시간을 측정한다.
- [x]  **ArrayList 순차 삽입:** 리스트의 끝에 요소를 N번 추가하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.4. Stream 반복 성능 비교
Stream 파이프라인 처리 오버헤드와 단순 반복문의 성능 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **Stream.forEach:** `stream()`을 사용하여 리스트의 요소를 N번 순회하며 시간을 측정한다.
- [x]  **Enhanced For Loop:** `for-each` 문을 사용하여 리스트의 요소를 N번 순회하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.5. 컬렉션 요소 포함 확인 성능 비교
자료구조의 탐색 시간 복잡도(O(N) vs O(1)) 차이로 인한 실제 성능 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **ArrayList.contains:** `contains()`로 리스트 내 요소를 N번 탐색하며 시간을 측정한다.
- [x]  **HashSet.contains:** `contains()`로 해시 테이블 내 요소를 N번 탐색하며 시간을 측정한다. (`contains()` 메서드를 사용하여 해싱(Hashing)을 통해 요소를 즉시 탐색한다.)
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.6. 배열 대량 복사 성능 비교
배열을 복사할 때, 반복문을 사용하는 방식과 JVM Native 기능을 사용하는 방식의 성능 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **For Loop Copy:** `for` 루프를 사용하여 배열 요소를 N번 수동 복사하며 시간을 측정한다.
- [x]  **System.arraycopy:** JVM의 Native 메서드를 사용하여 배열을 N번 복사하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.7. 키 기반 Map 조회 성능 비교
데이터 저장 구조(Tree vs Hash Table)의 차이가 조회 성능에 미치는 영향을 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **TreeMap.get:** 이진 트리 구조를 탐색하여 키를 N번 조회하며 시간을 측정한다.
- [x]  **HashMap.get:** 해싱을 통해 데이터 위치에 직접 접근하여 키를 N번 조회하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.8. 단순 문자열 치환 성능 비교
단순한 문자열을 치환할 때, 정규 표현식 엔진 사용 여부에 따른 성능 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **String.replaceAll:** 정규 표현식(Regex) 엔진을 사용하여 문자열을 N번 치환하며 시간을 측정한다.
- [x]  **String.replace:** 단순 문자열 매칭 알고리즘을 사용하여 문자열을 N번 치환하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.9. List 반복 중 안전한 삭제 비교
List를 순회하며 요소를 삭제할 때, 인덱스를 직접 다루는 방식과 Iterator를 사용하는 방식의 차이를 확인한다.
- [x]  사용자로부터 반복 횟수를 입력받는다.
- [x]  **For Loop remove(i):** 인덱스 기반 루프 내에서 요소를 삭제하고 인덱스를 직접 조정하며 시간을 측정한다.
- [x]  **Iterator.remove:** Iterator를 사용하여 요소를 N번 삭제하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

### 2.2.10. 병렬 스트림 성능 비교
단순 반복 작업에서 작업량에 따른 직렬(Sequential)과 병렬(Parallel) 처리의 효율성을 비교한다.
- [x]  사용자로부터 반복 횟수를 입력받는다. (1,000회 vs 1,000,000회 비교 권장)
- [x]  **Stream (Sequential):** 단일 스레드에서 순차적으로 스트림을 N번 처리하며 시간을 측정한다.
- [x]  **Parallel Stream:** 멀티 스레드를 사용하여 작업을 병렬로 N번 처리하며 시간을 측정한다.
- [x]  두 방식의 성능 차이를 시각화하여 출력한다.

## 2.3. 성능 비교 항목 분석 요약
| 번호 | 비교 주제 | Slow (비효율) | Fast (효율) | 분석 키워드 |
| --- | --- | --- | --- | --- |
| **1** | **문자열 연결** | String `+` | StringBuilder | 불변 객체(Immutable), GC 오버헤드 |
| **2** | **List 중간 삽입** | LinkedList | ArrayList | **CPU 캐시 지역성(Locality)**, 메모리 구조 |
| **3** | **List 순차 삽입** | LinkedList | ArrayList | 노드 객체 생성 비용, 메모리 파편화 |
| **4** | **반복(Iteration)** | Stream | Enhanced For-loop | 파이프라인 비용, JIT 컴파일러 최적화 |
| **5** | **요소 탐색** | ArrayList (O(N)) | HashSet (O(1)) | 시간 복잡도, 해싱(Hashing) 알고리즘 |
| **6** | **배열 복사** | For-loop | System.arraycopy | **JNI(Java Native Interface)**, Intrinsic 최적화 |
| **7** | **Map 조회** | TreeMap (O(\log N)) | HashMap (O(1)) | 이진 탐색 트리 vs 해시 테이블 |
| **8** | **문자열 치환** | replaceAll (Regex) | replace (Literal) | **정규표현식(Regex)** 엔진 구동 오버헤드 |
| **9** | **List 삭제** | Loop index | Iterator | 인덱스 관리 실수 방지, **안전성(Safety)** |
| **10** | **병렬 처리** | Parallel Stream | Stream | **ForkJoinPool**, 스레드 컨텍스트 스위칭 비용 |

## 2.4. 결과 출력 및 비교
- [x]  나노초(ns)로 측정된 시간을 가독성 좋게 1,000ms 미만은 밀리초(ms)로, 1,000ms 이상은 초(s)로 변환하여 출력한다.
- [x]  반복 횟수와 소요 시간 출력 시 천 단위 구분 기호(,)를 적용하여 가독성을 높인다.
- [x]  (느린 시간 / 빠른 시간) 공식을 사용하여 성능 차이 배수를 계산한 뒤, "A가 B보다 약 XX.XX배 빠릅니다" 형식으로 비교 결과를 출력한다.
- [x]  가장 느린 결과(100%)를 기준으로 상대적인 속도 비율을 막대 그래프로 출력한다.
- [x]  ANSI Color Code를 적용하여 빠른 결과(Green)와 느린 결과(Red)를 색으로 구분한다.
- [x]  두 테스트의 반복 횟수가 다를 경우, 비교를 건너뛰고 안내 메시지를 출력한다.
- [x]  사용자가 프로그램 종료 선택 시, 사용자에게 결과 파일 저장 여부(`y`/`n`)를 입력받는다.
    - [x]  파일 저장을 선택할 경우, 모든 분석 결과를 마크다운(.md)형식으로 `reports` 폴더에 저장한다.